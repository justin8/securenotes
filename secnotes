#!/bin/bash
MASTER_KEY='6D806CDF'
SETTINGS=~/.config/secnotes/config
KEYSTORE_LOCATION="${SETTINGS%/*}/keystore"
# Expected variables from settings:
# KEY_ID - the key ID to use for this user
# EMAIL - email of the generated key. Used for all encryption/decryption
# KEYSTORE - git repository of email/fingerprint pairs to trust
KEY_ID=''
EMAIL=''
if [[ -f $SETTINGS ]]; then
	while read -r line; do declare $line; done < $SETTINGS
fi

r() { tput setaf 1; tput bold; }
g() { tput setaf 2; tput bold; }
y() { tput setaf 3; tput bold; }
b() { tput setaf 4; tput bold; }
c() { tput sgr0; }
error() { echo "$(r)Error$(c): $*" >&2; }
warning() { echo "$(y)Warning$(c): $*" >&2; }
success() { echo "$(g)Success$(c): $*" >&2; }

# Handle updates at the start; less things to break beforehand if we need to push updates
if [[ $1 == '--update' ]]; then
	shift
	DIR="$(dirname "$(readlink -f "$0")")"
	UPDATE=$(git -C $DIR pull 2>&1)
	rc=$?
	if [[ $rc == 0 ]]; then
		if [[ $UPDATE != 'Already up-to-date.' ]]; then
			success 'Updated to latest version!'
		else
			success "$UPDATE"
		fi
	else
		error "Failed to update!"
		echo "$UPDATE"
	fi
	exit $rc
fi

# Detect and install packages if necessary
init() {
	local GPG_OUT
	mkdir -p $(dirname "$SETTINGS")
	if ! which gpg2 &>/dev/null || ! which tput &>/dev/null || ! which haveged &>/dev/null; then
		if uname -a | grep -qi darwin; then
			if ! which brew &> /dev/null; then
				ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
				brew doctor
			fi
			# TODO: see if haveged exists on OS X
			# TODO: check if OS X tput is as retarded as OS X echo; ncurses is in dupes; tput exists according to apple developer documentation
			brew install gnupg2
		elif grep -Ei "(ubuntu|debian)" /etc/os-release; then
			sudo apt-get install -y gnupg2 ncurses-bin haveged
		elif grep -i 'arch' /etc/os-release; then
			sudo pacman -S --noconfirm --needed gnupg2 ncurses haveged
		else
			error "Unable to find gpg2 or detect your OS version. Please install gpg2 manually"
		fi
	fi

	if ! which gpg2 &>/dev/null || ! which tput &>/dev/null || ! which haveged &>/dev/null; then
		error "A problem has occurred while trying to detect gpg2 and dependencies; please ensure it is available in your current environment"
	fi

	# Trust master key
	if ! gpg2 --list-keys 2>&1 | grep -q $MASTER_KEY; then
		warning "Master key not found. Downloading..."
		GPG_OUT=$(gpg2 --recv-key $MASTER_KEY 2>&1)
		rc=$?
		[[ $rc -ne 0 ]] && error "Failed retrieving master key!" && echo "$GPG_OUT" && exit $rc
	fi

	if ! gpg2 --list-keys --list-options show-uid-validity 2>&1 | grep -a1 $MASTER_KEY | grep -q 'ultimate'; then
		warning "Master key not ultimately trusted. Fixing..."
		OWNERTRUST=$(gpg2 --list-keys --with-fingerprint --with-colons 2>&1 | grep -A1 'ops@c9.io' | tail -n1 | tr -s : : | cut -d: -f2):6:
		GPG_OUT=$(gpg2 --import-ownertrust <<<"$OWNERTRUST" 2>&1)
	fi

	if [[ -d $KEYSTORE_LOCATION ]]; then
		git -C "$KEYSTORE_LOCATION" git fetch --all &>/dev/null
		git -C "$KEYSTORE_LOCATION" git reset --hard &>/dev/null
		git -C "$KEYSTORE_LOCATION" git checkout master &>/dev/null
		git -C "$KEYSTORE_LOCATION" git reset --hard origin/master &>/dev/null
	fi
}

grep_email() {
	grep uid | sed -E 's/.*<(.*)>.*$/\1/'
}

grep_keyid() {
	grep pub | sed -E 's|.*/([a-zA-Z0-9]+).*$|\1|'
}

check_for_secret_key() {
	[[ -z $EMAIL ]] && return 1
	[[ -z $KEY_ID ]] && return 1

	SECRET_KEYS=$(gpg2 --list-secret-keys 2>&1)
	GPG_EMAIL=$(grep -A1 "$KEY_ID" <<<"$SECRET_KEYS" | grep_email)
	[[ $GPG_EMAIL == "$EMAIL" ]] && return 0
	return 1
}

# Use GPG to generate a key and store the key variables for later use
generate_key() {
	[[ ! -d $KEYSTORE_LOCATION ]] && error 'Please specify a keystore repository before generating your key' && exit 1
	# TODO: May not work in docker containers. Need to test; or ignore because this should be on local host only
	ps aux | grep haveged|grep -qv grep || sudo haveged
	if check_for_secret_key; then
		echo "A key has already been generated. Are you sure you want to continue? [y/N]"
		read -r response
		case $response in
			y|Y)echo '';;
			*)exit 1;;
		esac
	fi

	# TODO: Use a key settings file with --gen-key --batch over stdin to support old gpg on Ubuntu/OSX
	# use `read -s variable` for it
	NEW_KEY=$(gpg2 --gen-key)
	KEY_ID=$(grep_keyid <<<"$NEW_KEY")
	EMAIL=$(grep_email <<<"$NEW_KEY")
	EMAIL=${EMAIL,,}
	[[ -z $KEY_ID ]] && error 'Failed to generate key!' && return 1
	[[ -z $EMAIL ]] && error 'Failed to generate key!' && return 1
	GPG_OUT=$(gpg2 --send-key "$KEY_ID" 2>&1)
	rc=$?
	# TODO: Cleanup after failure to upload?
	[[ $rc -ne 0 ]] && error 'Failed to upload key to server!' && echo "$GPG_OUT" && return $rc

	# Attempt to silently clear branches of the existing name before doing set -e
	git -C "$KEYSTORE_LOCATION" branch -D "$EMAIL"
	set -e
	trap 'error Failed to upload new key to keystore' SIGQUIT SIGINT SIGTERM EXIT
	# Save key to repo and push in a branch
	echo "$KEY_ID" > "$KEYSTORE_LOCATION/$EMAIL"
	git -C "$KEYSTORE_LOCATION" checkout -b "$EMAIL"
	git -C "$KEYSTORE_LOCATION" add "$EMAIL"
	git -C "$KEYSTORE_LOCATION" commit -m "New key for $EMAIL"
	git -C "$KEYSTORE_LOCATION" push --set-upstream origin HEAD
	git -C "$KEYSTORE_LOCATION" checkout master
	trap - SIGQUIT SIGINT SIGTERM EXIT
	set +e

	# Save settings for future use
	echo "KEY_ID=$KEY_ID" > "$SETTINGS"
	echo "EMAIL=$EMAIL" >> "$SETTINGS"
	success "The new key has been generated and saved successfully"
	return 0
}

get_keyid_from_email() {
	local TARGET=${1,,}
	local fullname="$KEYSTORE_LOCATION/$TARGET"
	local shortname=$(find "$KEYSTORE_LOCATION" -maxdepth 1 -iname "$TARGET*")

	# keystore lookup
	for file in $fullname $shortname; do
		[[ -f $file ]] && cat "$file" && return 0
	done

	# TODO: Implement remote keystore lookup here after falling through local checks
	error 'Failed to find key locally. Remote lookups coming soon'
	return 1
}

# Attempt to recieve the specified KEYID; fallback to local cache if it fails
get_public_key() {
	local GPG_OUT
	local rc=0
	local KEYID="$1"

	GPG_OUT=$(gpg2 --recv-key "$KEYID" 2>&1)
	rc=$?

	if gpg --list-keys | grep -q $KEYID; then
		if [[ $rc -eq 0 ]]; then
			return 0
		else
			warning 'Failed to update key. Falling back to local cache.'
			rc=0
		fi
	else
		error 'Failed to retrieve key'
	fi
	echo $GPG_OUT
	return $rc
}

encrypt_message() {
	local GPG_OUT
	local INPUT
	local KEYID
	local rc=0

	if ! check_for_secret_key; then
		error "You must generate a key before being able to encrypt"
		exit 1
	fi

	[[ -z $RECIPIENT ]] && error "No recipient specified! This shouldn't happen." && exit 1

	# Set $KEYID assuming $RECIPIENT is an email. Fallback to using it as the ID itself
	KEYID=$(get_keyid_from_email $RECIPIENT)
	[[ -z $KEYID ]] && KEYID=$RECIPIENT
	get_public_key "$KEYID"
	[[ $? -ne 0 ]] && exit 1

	if [[ $FILE == - ]]; then
		# File is stdin
		GPG_OUT=$(gpg2 -r $RECIPIENT --armor --encrypt 3>&1 1>&2 2>&3)
		rc=$?
	elif [[ -n $FILE ]]; then
		# File is a file
		[[ ! -f $FILE ]] && error "Please specify a valid file" && exit 1
		GPG_OUT=$(gpg2 -r $RECIPIENT --armor --encrypt 3>&1 1>&2 2>&3 < "$FILE")
		rc=$?
	else
		# No file specified
		echo "Please paste the message to be encrypted below. press ctrl+d to end the message:"
		INPUT=$(cat)
		echo
		echo ----------------------------------------------------------------
		echo
		echo "$(b)Encrypted message$(c):"
		GPG_OUT=$(gpg2 -r $RECIPIENT --armor --encrypt 3>&1 1>&2 2>&3 <<<"$INPUT")
		rc=$?
	fi

	3>&-
	if [[ $rc -ne 0 ]]; then
		error "Failed to encrypt message!"
		echo "$GPG_OUT"
	fi
	return $rc

}

decrypt_message() {
	local GPG_OUT
	local INPUT
	local rc=0
	if ! check_for_secret_key; then
		error "You must generate a key before being able to decrypt"
		exit 1
	fi

	if [[ $FILE == - ]]; then
		# File is stdin
		GPG_OUT=$(gpg2 3>&1 1>&2 2>&3)
		rc=$?
	elif [[ -n $FILE ]]; then
		[[ ! -f $FILE ]] && error "Please specify a valid file" && exit 1
		# File is a file
		GPG_OUT=$(gpg2 3>&1 1>&2 2>&3 < "$FILE")
		rc=$?
	else
		# No file specified
		echo "Please paste the message to be decrypted below:"
		while read -r line; do
			[[ -z $INPUT ]] && INPUT="$line" || INPUT="$INPUT"$'\n'"$line"
			[[ $line == '-----END PGP MESSAGE-----' ]] && break
		done
		echo
		echo ----------------------------------------------------------------
		echo
		echo "$(b)Decrypted message$(c):"
		GPG_OUT=$(gpg2 3>&1 1>&2 2>&3 <<<"$INPUT")
		rc=$?
	fi

	3>&-
	if [[ $rc -ne 0 ]]; then
		error "Failed to decrypt message!"
		echo "$GPG_OUT"
	fi
	return $rc
}

# set a git repo to use for validating fingerprints
set_keystore() {
	[[ -z $KEYSTORE ]] && error "No keystore specified! This shouldn't happen" && exit 1
	if [[ -d $KEYSTORE_LOCATION ]]; then
		error "A keystore has already been specified. Are you sure you wish to overwrite it? [y/N]"
		read -r response
		case $response in
			y|Y)echo '';;
			*)exit 1;;
		esac
		rm -rf "$KEYSTORE_LOCATION"
	fi

	handler() {
		error 'Failed to sync keystore!'
		exit 1
	}

	set -e
	trap handler SIGTERM SIGINT SIGQUIT EXIT
	# Github shortname handling
	if ! [[ $KEYSTORE =~ (@|:) ]]; then
		KEYSTORE="git@github.com:$KEYSTORE"
	fi
	git clone "$KEYSTORE" "$KEYSTORE_LOCATION" &>/dev/null

	set +e
	trap - SIGTERM SIGINT SIGQUIT EXIT
	success 'Synced keystore.'
	return 0
}

usage() {
	cat <<-EOF
	Usage: $(basename "$(readlink "$0")") [options]

	With nothing specified the tool will default to decrypting a message.

	The message to be decrypted/encrypted will be requested on the terminal.
	If you wish to decrypt/encrypt from stdin, use '-f -'. To use a file
	specify '-f \$FILENAME'.

	Options:
	 -h         Show this $(b)H$(c)elp
	 -e email   $(b)E$(c)ncrypt a message (typed/pasted in. file/stdin with '-f')
	            You must specify the email of the person you intend to send this to
	 -f file    Specify a $(b)F$(c)ile. Specifying '-' will use stdin
	 -g         $(b)G$(c)enerate a key pair; This should only be needed once
	 -s repo    $(b)S$(c)et a git repo as the keystore for verifying key IDs
	EOF
}

init

FILE=''
TASK=decrypt_message
while getopts ":hgde:s:f:" OPTION
do
	case $OPTION in
		h) usage; exit 0 ;;
		g) TASK=generate_key ;;
		e) TASK=encrypt_message; RECIPIENT="$OPTARG" ;;
		f) FILE=$OPTARG ;;
		s) TASK=set_keystore; KEYSTORE="$OPTARG" ;;
		?) usage; error "Unknown option"; exit 1;;
	esac
done
shift $(( OPTIND -1 ))

$TASK
